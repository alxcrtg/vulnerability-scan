import {Toolkit} from 'actions-toolkit'
import fs from 'fs'
import semver from 'semver'
import {table} from 'table'

const BATCH_SIZE = 10

declare module 'table' {
  interface ColumnConfig {
    wordWrap?: boolean
  }
}

/* eslint-disable no-unused-vars */
enum Ecosystem {
  NPM = 'NPM'
}

enum Severity {
  Low = 'LOW',
  Moderate = 'MODERATE',
  High = 'HIGH',
  Critical = 'CRITICAL'
}
/* eslint-enable no-unused-vars */

const SeverityLevels = {
  [Severity.Low]: 0,
  [Severity.Moderate]: 1,
  [Severity.High]: 2,
  [Severity.Critical]: 3
}

type Alert = {
  package: {name: string}
  version: string
  vulnerableVersionRange: string
  severity: string
  advisory: {
    description: string
    publishedAt: string
    ghsaId: string
    references: {url: string}[]
  }
}

type Dependency = {
  name: string
  spec: string
  version: string
}

type DependencySet = {
  [key: string]: Dependency
}

Toolkit.run(async tools => {
  let alerts: Alert[] = []

  try {
    const noDev = getNoDev(tools.arguments.dev)
    const ecosystem = getEcosystem(tools.arguments.ecosystem)
    const severity = getSeverity(tools.arguments.severity)
    const manifestPath = getManifestPath(ecosystem)
    const manifest = JSON.parse(fs.readFileSync(manifestPath).toString())
    const dependencies = getAllDependencies(manifest.dependencies, {noDev})

    tools.log.info(`Checking ${dependencies.length} dependencies.`)

    alerts = await collectAlerts(ecosystem, severity, tools, dependencies)
  } catch (err) {
    if (process.env.FAIL_NEUTRAL === 'true') {
      tools.log.error(err)
      tools.exit.neutral('Security vulnerabilities found.')
    } else {
      throw err
    }
  }

  if (alerts.length === 0) {
    tools.exit.success('No security vulnerabilities found.')
  } else {
    printAlertsTable(alerts)
    tools.exit.failure('Security vulnerabilities found.')
  }
})

function getNoDev(dev: boolean | undefined) {
  return dev == null ? process.env.NO_DEV === 'true' : !dev
}

function getEcosystem(ecosystem: string | undefined) {
  if (ecosystem == null) {
    ecosystem = process.env.ECOSYSTEM
  }

  switch (ecosystem) {
    case 'npm':
      return Ecosystem.NPM
    default:
      throw new Error(`Not a valid ecosystem: "${ecosystem}"`)
  }
}

function getSeverity(severity: string | undefined) {
  if (severity == null) {
    severity = process.env.SEVERITY || 'low'
  }

  switch (severity) {
    case 'low':
      return Severity.Low
    case 'moderate':
      return Severity.Moderate
    case 'high':
      return Severity.High
    case 'critical':
      return Severity.Critical
    default:
      throw new Error(`Not a valid severity level: "${severity}"`)
  }
}

function getManifestPath(ecosystem: Ecosystem) {
  if (process.env.MANIFEST_PATH != null) return process.env.MANIFEST_PATH

  return {
    [Ecosystem.NPM]: './package-lock.json'
  }[ecosystem]
}

/**
 * Collect all active alerts for this manifest.
 */
async function collectAlerts(
  ecosystem: Ecosystem,
  severity: Severity,
  tools: Toolkit,
  dependencies: Dependency[]
): Promise<Alert[]> {
  const alertLists = await doInBatches(dependencies, BATCH_SIZE, dependency => {
    return listAlerts(ecosystem, severity, tools, dependency)
  })

  return alertLists.flat()
}

type SecurityVulnerabilitiesResult = {
  securityVulnerabilities: {
    edges:
      | null
      | {
          cursor: string
          node: null | Pick<Alert, Exclude<keyof Alert, 'version'>>
        }[]
  }
}

/**
 * List all alerts for a dependency.
 *
 * This recursively calls itself for collecting further pages of alerts, if need be (one would
 * hope not!)
 */
async function listAlerts(
  ecosystem: Ecosystem,
  severity: Severity,
  tools: Toolkit,
  dependency: Dependency,
  cursor: string | null = null,
  alerts: Alert[] = []
): Promise<Alert[]> {
  if (!cursor) tools.log.info(`Checking alerts for ${dependency.spec}`)

  const result: SecurityVulnerabilitiesResult = await tools.github.graphql(
    `
      query(
        $ecosystem: SecurityAdvisoryEcosystem!
        $package: String!
        $cursor: String
      ) {
        securityVulnerabilities(
          first: 100
          ecosystem: $ecosystem
          package: $package
          after: $cursor
        ) {
          edges {
            cursor

            node {
              severity
              vulnerableVersionRange

              package {
                name
              }

              advisory {
                description
                publishedAt
                ghsaId

                references {
                  url
                }
              }
            }
          }
        }
      }
    `,
    {
      ecosystem,
      package: dependency.name,
      cursor
    }
  )

  const edges = result.securityVulnerabilities.edges || []

  if (edges.length === 0) {
    if (alerts.length > 0) {
      tools.log.warn(
        `${alerts.length} active vulnerabilities found for ${dependency.spec}.`
      )
    } else {
      tools.log.success(`No vulnerabilities found for ${dependency.spec}.`)
    }
    return alerts
  }

  const nextCursor = edges[edges.length - 1].cursor
  const newAlerts: Alert[] = edges
    .filter(
      ({node}) =>
        node &&
        SeverityLevels[node.severity as Severity] >=
          SeverityLevels[severity as Severity]
    )
    .map(edge => {
      return {...edge.node!, version: dependency.version}
    })
  const activeAlerts = filterActiveAlerts(newAlerts, dependency.version)

  alerts = alerts.concat(activeAlerts)

  return await listAlerts(
    ecosystem,
    severity,
    tools,
    dependency,
    nextCursor,
    alerts
  )
}

/**
 * Filter active alerts by seeing if the current version satisfies ther vulnerable range.
 */
function filterActiveAlerts(alerts: Alert[], version: string) {
  return alerts.filter(alert => {
    return semver.satisfies(version, alert.vulnerableVersionRange)
  })
}

type PackageDependencies = {
  [key: string]: Dependency & {
    dependencies: PackageDependencies
    dev?: boolean
  }
}

/**
 * Get all dependencies, recursively.
 */
function getAllDependencies(
  dependencies: PackageDependencies,
  {noDev}: {noDev: boolean},
  depSet: DependencySet = {}
): Dependency[] {
  for (const dependencyName in dependencies) {
    const dependency = dependencies[dependencyName]
    const spec = `${dependencyName}@${dependency.version}`

    if (noDev && dependency.dev) {
      continue
    }

    depSet[spec] = {
      name: dependencyName,
      version: dependency.version,
      spec
    }

    if (dependency.dependencies) {
      getAllDependencies(dependency.dependencies, {noDev}, depSet)
    }
  }

  return Object.values(depSet)
}

/**
 * Print a human-readable table of alerts.
 */
function printAlertsTable(alerts: Alert[]) {
  const alertData = alerts.map(alert => {
    return [
      `${alert.package.name}@${alert.version}`,
      alert.vulnerableVersionRange,
      alert.advisory.publishedAt,
      alert.severity,
      alert.advisory.ghsaId,
      `${alert.advisory.description}\n\n${alert.advisory.references
        .map(ref => ref.url)
        .join('\n')}`
    ]
  })

  alertData.unshift([
    'Package',
    'Vulnerable Range',
    'Published At',
    'Severity',
    'GHSA ID',
    'Description'
  ])

  process.stdout.write(
    `${table(alertData, {
      columns: {
        5: {
          width: 80,
          wordWrap: true
        }
      }
    })}\n`
  )
}

async function doInBatches<T, R>(
  data: T[],
  batchSize: number,
  fn: (datum: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = []

  for (const batch of chunk(data, batchSize)) {
    const batchResults = await Promise.all(batch.map(fn))
    results.push(...batchResults)
  }

  return results
}

function* chunk<T>(data: T[], size: number): IterableIterator<T[]> {
  const chunkCount = Math.ceil(data.length / size)

  for (let i = 0, j = 0; i < chunkCount; i++, j += size) {
    yield data.slice(j, j + size)
  }
}
