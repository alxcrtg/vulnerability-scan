# Vulnerability Scanner

This action parses a manifest file (such as a `package-lock.json`) and checks if GitHub has any security vulnerabilities detected for packages in that manifest file.

In order to use it, you can write a workflow such as this one:

```workflow
workflow "Security Scan" {
  on = "push"
  resolves = "Scan Dependencies"
}

action "Install Dependencies" {
  uses = "actions/npm@v1.0.0"
  args = "ci"
}

action "Scan Dependencies" {
  uses = "actions/vulnerability-scan@v1.0.0"
  needs = "Install Dependencies"
  env = {
    ECOSYSTEM = "npm"
    SEVERITY = "low"
  }
  secrets = ["GITHUB_TOKEN"]
}
```

For another example, see [this repository's workflow](.github/main.workflow).

If the action fails, you'll see a table at the bottom of the action's output outlining what packages are vulnerable.

## Configuring

In order to configure this action, pass environment variables:

- `ECOSYSTEM` (one of: `["npm"]`) This tells the action what ecosystem manifest file to use.
- `SEVERITY` (one of: `["low", "moderate", "high", "critical"]`, default `"low"`) This is a lower bound for the severity of vulnerability that will trigger a failure in this action.
- `MANIFEST_PATH` (omit or provide a path) This can be used to override the default manifest path used by the action for a given ecosystem.
- `NO_DEV` (omit or `"true"`) This can be used to omit non-production dependencies.
- `FAIL_NEUTRAL` (omit or `"true"`) This can be used to ensure that the action fails with a neutral status in the event of a non-vulnerability-related error (useful if it's frequently hitting API rate limits, but beware of false positives).

## Contributing

Check out [this doc](CONTRIBUTING.md).

## License

This action is released under the [MIT license](LICENSE.md).
Container images built with this project include third party materials. See [THIRD_PARTY_NOTICE.md](THIRD_PARTY_NOTICE.md) for details.

## Current Status

This action is in active development. One current limitation is that this action will sometimes hit API rate limits for projects with big enough dependencies. A future iteration may (partially) solve this by being meant to run on pull requests and checking only *new* dependencies.